/* Рассмотрим последнюю демку, где код, который до текущего момента казался хорошим и
даже работал, на самом деле оказался не таким хорошим. Разберём пример из предыдущей
лекции по рекурсии, где мы делали закрашивание замкнутой области. На примере квадратика.
Он будет выглядеть как прямоугольник, но
это квадратик. Далее делаем обрамление единичками и печатаем его. Методом закрашивания
сделаем закрашивание внутренней области. Итак, изначально он был не закрашенным, а
после этого стал закрашенным.
Теперь немного повеселимся и в качестве картинки возьмём значение не 10x10, а 1000x1000,
для современных экранов это небольшая картинка. Дальше по понятным причинам я не буду
14
пытаться делать распечатывание этой картинки, потому что в консоль это не влезет. Однако
запустим систему и посмотрим, к чему это всё приведёт.
Снова вышел stack overflow. Почему это случилось? Дело в том, что код, закрашивающий
определённую область, для каждой точки нашей картинки будет вызывать четыре вызова
рекурсии. Получается много избыточных элементов — избыточного обхода точек. Мы
просматриваем много ненужных точек, которые даже нет смысла просматривать.
Можно ли как-то оптимизировать и улучшить код? Да, можно. Но тогда этот код уже будет
составлять не четыре строчки, а гораздо больше, поэтому станет не таким интересным
*/

int[,] pic = new int[10, 10]; // наш квадратик

for (int i = 0; i < 10; i++) // делаем обрамление нашего квадрата единицами
{
    pic[0, i] = 1;
    pic[i, 0] = 1;
    pic[i, 9] = 1;
    pic[9, i] = 1;
}

PrintImage(pic);
FillImage(1, 1);
Console.WriteLine();
PrintImage(pic);

void PrintImage(int[,] image)
{
    for (int i = 0; i < image.GetLength(0); i++)
    {
        for (int j = 0; j < image.GetLength(1); j++)
        {
            if (image[i, j] == 0) Console.Write($" ");
            else Console.Write("+");
        }
        Console.WriteLine();
    }
}

void FillImage(int row, int col) // метод для закрашивания при помощи рекурсии
{
    if (pic[row, col] == 0)
    {
        pic[row, col] = 1;
        FillImage(row - 1, col);
        FillImage(row, col - 1);
        FillImage(row + 1, col);
        FillImage(row, col + 1);
    }
}

